#!/usr/bin/perl 
# contig_classifier.pl 
# Sheila Podell 
# February 18, 2017

#	Takes as input:
	# 1) DarkHorse tab-delimited smry output file containing 
#	multiple ORFs predicted from contigs or scaffolds
#	2) tab-delimited index file linking orfs to parent contigs, two columns:
	#contig_id
	# predicted protein id
#	3) file of search terms (most abundant, generated by cluster_lineages.pl)
#	4) optional parameter: minumum number of orfs per contig (default 10)

# Finds consensus lineages (if possible) for each contig with > minimum hits
	# runs DarkHorse taxonomy calculation on each lineage, returns LPI scores
	# reports dh_tophit + LPI score
	# reports LCA_tophit + LPI score for tophit 
	# reports % matches for dh_tophit, LCA_tophit
	
# counts hits to each of specific search terms provided
	# reports non-zero results as % of proteins hit

#	Output goes to STDOUT, in following tab-delimited format:
# contig_id
# total_num_ORFs
# num_uniq_lineages
# top_search_term1_%hits
# top_search_term2_%hits
# top_search_term3_%hits
# dh_tophit_lineage_LPI
# (for all lineages with LPI > 0.9)

use warnings; 
use strict;
use Getopt::Long;

# Global defaults
	my ($dh_smry_filename, $ctg_index_filename, $search_list_filename);
	my $min_num_orfs = 10;
	my $tally_cols = 3;
		
# get command line arguments
	my $USAGE;
	my $message = qq(
   Usage: $0 -d darkhorse_smry_file -i contig_index_file -s search_list_file
   optional parameters: 
   -n min_num_orfs/contig \(default = 10\)
   -t tally columns \(default = 3\)	
	)."\n";

	GetOptions( "d=s" => \$dh_smry_filename,
"i=s" => \$ctg_index_filename,
"n=i" => \$min_num_orfs,
"t=i" => \$tally_cols,
"s=s"	=> \$search_list_filename,
        );

# validate input
	if($USAGE || !$dh_smry_filename || !$ctg_index_filename || !$search_list_filename) 
    {
		print STDERR "$message";
		exit(0);
	} 
	
# open contig id file
	# create new contig object for each contig
	my %gene_ctg_index =(); # key = orf_name  # value = contig name
	my %contig_objects = (); # key = contig_name #value = object reference
	my $current_contig;
	my $num_errors = 0;
	open (INDEX,"$ctg_index_filename") or die "can't open input file $ctg_index_filename\n$!\n";
	while (<INDEX>) 
	{
		next if ($_ =~ /^\s/);
		next if ($_ =~ /query/); #skip header line
		chomp;
		my @tmp = split "\t", $_;
		my ($gene_id, $contig_id);
		if (scalar @tmp == 2)
		{
			$gene_id = $tmp[1];
			$contig_id = $tmp[0];
			$gene_ctg_index{$gene_id} =$contig_id;
			unless (exists $contig_objects{$contig_id})
			{
				$current_contig = &new_contig($contig_id);
				$contig_objects{$contig_id} = $current_contig;
			}
		}
		else
		{
			print STDERR "incorrect number of fields, line $.: $_\n";
			$num_errors++;
			if ($num_errors >10)
			{
				print STDERR " FATAL ERROR: too many bad lines in contig index $ctg_index_filename\n";
			}
			next;
		}
	}
	close (INDEX);
	
	my $num_contigs = scalar keys %contig_objects;
	print STDERR "   Found $num_contigs contigs in contig_index file $ctg_index_filename\n";

# collect search terms from file
	open (SEARCH_LIST, "$search_list_filename") or die "can't open input file $search_list_filename\n$!\n";
	my %search_list = ();
	my @keywords = ();
	while (<SEARCH_LIST>) 
	{
		chomp;
		next if ($_ =~ /^\s/);
		next unless (defined $_ && length $_ >1);
		$search_list{$_} = 0;
		push @keywords, $_;
	}
	close SEARCH_LIST;

# Collect scaffold lines together in a hash, keyed by by scaffold id number
	my $num_dh_hits = 0;
	open (DH_SMRY,"$dh_smry_filename") or die "can't open input file $dh_smry_filename\n$!\n";		
	while (<DH_SMRY>) 
	{
		next if ($_ =~ /^\s/);
		next if ($_ =~ /query/); #skip header line
		chomp;
		my @tmp = split "\t", $_;
		my $gene_id = $tmp[0];
		my $lineage = $tmp[14];

		my $contig_id = $gene_ctg_index{$gene_id};
		if (defined $contig_id && exists $gene_ctg_index{$gene_id}) 
		{
			$contig_objects{$contig_id}->{num_genes}++;
			push @{$contig_objects{$contig_id}->{lineages}}, $lineage;
		}
		else
		{
			print STDERR " WARNING: no contig_id found for gene $gene_id\n";
			next;
		}
		$num_dh_hits++;	
	}
	close DH_SMRY;
	
	#print STDERR "   Found $num_dh_hits orfs with database matches.\n";
	
# print headers
	my @header = (
		"contig_id",
		"total_orfs",
		"num_uniq_lineages",);
		for (my $i=1; $i< $tally_cols +1; $i++)
		{
			my $name = "top_term"."$i"."_pct";
			push @header, $name;
		}
		for (my $i=1; $i< $tally_cols +1; $i++)
		{
			my $name = "top_lineage"."$i"."_LPI";
			push @header, $name;
		}
				
	my $header_string = join "\t", @header;			
		print	"$header_string\n";

# analyze contigs, print output
	my $filtered_number = 0;	
	foreach my $next_ctg (sort keys %contig_objects)
	{
		my $num_genes = $contig_objects{$next_ctg}->{num_genes};
	
	# filter out if too few genes	
		next if $num_genes < $min_num_orfs;
		$filtered_number++;
		
		my @lineage_list = @{$contig_objects{$next_ctg}->{lineages}};
		my %uniq_lineages = ();
		foreach my $next_lineage (@lineage_list)
		{
			$uniq_lineages{$next_lineage}++;
		}
		my $num_unique_lineages = scalar keys %uniq_lineages;	
		my %lpi_score_hash = &get_norm_lpi_scores($next_ctg,\%uniq_lineages);
		my @lpi_sorted_lineages = sort {$lpi_score_hash{$b} <=> $lpi_score_hash{$a}} keys %lpi_score_hash;
	
	# get list of lineages with norm LPI scores > 0.9
		my $topscore = $lpi_score_hash{$lpi_sorted_lineages[0]};
		my @topscoring_lineages = ();
		my %keyword_hits = ();
		foreach my $lineage (@lpi_sorted_lineages)
		{
		# check to see if any of search terms are present 
			foreach my $keyword (@keywords)
			{
				if ($lineage =~ /$keyword/)
				{
					$keyword_hits{$keyword}++;
				}
			}					
			my @tmp = split ";", $lineage;
			my $num_terms = scalar @tmp;
			my $lpi_score = $lpi_score_hash{$lineage};
			my $formatted_lpi_score = sprintf("%.3f", "$lpi_score");
			if ($num_terms > 3)
			{
				push @topscoring_lineages, "$lineage"."_"."$formatted_lpi_score";
			}
		}
		
		my @output_cols = ($next_ctg, $num_genes, $num_unique_lineages);
		my @kw_cols = ();
		my $kw_num = 0;
		foreach my $kw (sort {$keyword_hits{$b} <=> $keyword_hits{$a}
						|| $a cmp $b} keys %keyword_hits)
		{
			my $pct = ($keyword_hits{$kw}/$num_genes)*100 ;
			my $formatted_pct = sprintf ("%d", $pct);
			$formatted_pct = "$formatted_pct"."%";
			my $kw_info = "$kw"."_"."$formatted_pct";
			push @kw_cols, $kw_info;
			$kw_num++;
			last if $kw_num > $tally_cols -1;
		}
	# make sure there are the correct number of kw columns
		for (my $i=0; $i<$tally_cols; $i++)
		{
			unless (defined $kw_cols[$i] and length $kw_cols[$i] > 2)
			{
				$kw_cols[$i] = "none";
			}
		}  
		my @top_lineages = ();
		for (my $i=0; $i<$tally_cols; $i++)
		{
			if (defined $topscoring_lineages[$i] && length $topscoring_lineages[$i] > 10)
			{
				push @top_lineages, $topscoring_lineages[$i]; 
			}
			else
			{
				push @top_lineages, "none";
			}
		}
		my $printstring = join "\t", (@output_cols, @kw_cols, @top_lineages);
	
		print "$printstring\n";
	}

print STDERR "   Analyzed $filtered_number contigs containing > $min_num_orfs orfs with database matches.\n";
	
#####################
# SUBROUTINES
#####################

sub new_contig {
  my ($className, $contig_id, $param) = @_;
  my $self = {};
  bless $self, $className;
	$self->{name} = $contig_id;
	$self->{num_genes} = 0;
	my @lineages = ();
	my $lineage_arrayref = \@lineages;
	$self->{lineages} = $lineage_arrayref;
	
  return($self);
}

sub get_norm_lpi_scores
{
	my ($ctg_id, $lineage_hashref) = @_;
	my %ctg_lineages = %{$lineage_hashref};
	my $tmp_lineages = "contig_classifier_lineages_tmp";
	my $tmp_LPI = "contig_classifier_LPIs_tmp";

# put lineages into tempfile

	open (TMP_LINEAGES,">$tmp_lineages") or die "can't open temp file $tmp_lineages for writing\n$!\n";
	foreach my $key (keys %ctg_lineages)
	{
		next if ($key =~ /^\s+$/);
		print TMP_LINEAGES "$key\t\n";
	}
	close TMP_LINEAGES;	

# get LPI scores from calc_lineage_probability.pl
	unless (-e "calc_lineage_probability.pl")
	{
		print STDERR " can't find required accessory file calc_lineage_probability.pl in current working directory\n";
		exit(0);
	}
	
	my $cmd = "./calc_lineage_probability.pl $tmp_lineages > $tmp_LPI";
	`$cmd`;
	
	open (TMP_LPI, "$tmp_LPI") or die "can't open temp file $tmp_LPI for reading\n$!\n";
	my %lpi_scores = ();
	while (<TMP_LPI>)
	{
		chomp;
		next if ($_ =~ /^\s$/);
		my @tmp = split "\t", $_;
		my $current_lineage = $tmp[0];
		my $current_lpi = $tmp[1];
		next unless (defined $current_lineage);
		
		$lpi_scores{$current_lineage}=$current_lpi;
	}
	close TMP_LPI;
	
	unlink "$tmp_lineages";
	unlink "$tmp_LPI";
# normalize lineage scores
	my @sorted = sort {$lpi_scores{$b} <=> $lpi_scores{$a}} keys %lpi_scores;
	my $topscore = $lpi_scores{$sorted[0]};
	foreach my $key (@sorted)
	{
		my $norm_lpi = $lpi_scores{$key}/$topscore;
		$lpi_scores{$key} = $norm_lpi;
	}	
	
	return %lpi_scores;
}
	
__END__
